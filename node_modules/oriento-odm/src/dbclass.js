"use strict";

var shortid = require("shortid"),
	inherit = require("./clazz").inherit;

function DBClass(data) {
    var self = this;
    if (data) {
        for (var key in data) {
            if (data.hasOwnProperty(key) && key.substr(0,1) != "@" && key.substr(0, 3) != "in_" && key.substr(0, 4) != "out_")
            {
                self[key] = data[key];
            }
        }
        var rid = data["@rid"];
        if (rid) {
            if (rid.cluster && rid.position) {
                rid = "#" + rid.cluster + ":" + rid.position;
            }
            self["@rid"] = rid;
        }
    }
    if (!self.id) {
        self.id = shortid.generate();
    }
}

/* -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- */

DBClass.subclass = function(ctor) {
	inherit(ctor, this);
};

DBClass.create = function(db, callback) {
    var Clazz = this;
    db.class.get(Clazz.name).then(function(TheClazz) {
        callback(null, TheClazz);
    }).catch(function() {
        db.class.create(Clazz.name, "V").then(function(TheClazz) {
            callback(null, TheClazz);
        }).catch(callback);
    });
};

DBClass.drop = function(db, callback) {
    var Clazz = this;
    Clazz.delete(db, function(err) {
        if (err) {
            callback(err);
        } else {
            db.query("DROP CLASS " + Clazz.name).then(function(resp) {
                callback(null, resp);
            }).catch(callback);
        }
    });
};

DBClass.find = function(db, criteria, callback, selectWhat) {
    var Clazz = this;
    if (!callback && typeof criteria == "function") {
        callback = criteria;
        criteria = null;
    }
    var promise = db.select(selectWhat).from(Clazz.name);
    if (criteria && (typeof criteria != "object" || Object.keys(criteria).length > 0)) {
        promise.where(criteria);
    }
    promise.all().then(function(found) {
        var res = [];
        for (var i in found) {
            res.push(new Clazz(found[i]));
        }
        callback(null, res);
    }).catch(callback);
};

DBClass.findOne = function(db, criteria, callback, selectWhat) {
    var Clazz = this;
    if (!callback && typeof criteria == "function") {
        callback = criteria;
        criteria = null;
    }
    var promise = db.select(selectWhat).from(Clazz.name);
    if (criteria && (typeof criteria != "object" || Object.keys(criteria).length > 0)) {
        promise.where(criteria);
    }
    promise.all().then(function(found) {
        if (found.length == 1) {
            callback(null, new Clazz(found[0]));
        } else if (found.length > 1) {
            callback(new Error("Multiple records found"));
        } else {
            callback(null, null);
        }
    }).catch(callback);
};

DBClass.findById = function(db, id, callback, selectWhat) {
    var Clazz = this;
    Clazz.findOne(db, { id: id }, callback, selectWhat);
};

DBClass.insert = function(db, data, callback) {
    var Clazz = this;
    if (!data) {
        data = {};
    }
    if (!data.save || !data.id) {
        try {
            data = new Clazz(data);
        } catch(ex) {
            return callback(ex);
        }
    }
    data.save(db, callback);
};

DBClass.delete = function(db, criteria, callback) {
    var Clazz = this;
    if (!callback && typeof criteria == "function") {
        callback = criteria;
        criteria = {};
    }
    if (!criteria) {
        criteria = {};
    }
    criteria["@class"] = Clazz.name;

    db.delete('VERTEX').where(criteria).scalar().then(function(total) {
        callback(null, total);
    }).catch(callback);
};

/* -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- */

DBClass.prototype.save = function(db, callback) {
    var self = this,
        Clazz = this.constructor;
    // do not persist special symbols, only data
    var fields = {};
    for (var key in self) {
        if (self.hasOwnProperty(key) && key.substr(0,1) != "@" && key.substr(0,1) != "#" &&
            key.substr(0, 3) != "in_" && key.substr(0, 4) != "out_")
        {
            fields[key] = self[key];
        }
    }

    if (self["@rid"]) {
        var criteria = { "@rid": self["@rid"] };
        db.update(Clazz.name).set(fields).where(criteria).scalar().then(function(total) {
            if (total != 1) {
                callback(new Error(total + " records updated"));
            } else {
                Clazz.findOne(db, criteria, callback);
            }
        }).catch(callback);
    } else {
        db.insert().into(Clazz.name).set(fields).one().then(function(inserted) {
            callback(null, new Clazz(inserted));
        }).catch(callback);
    }
};

DBClass.prototype.delete = function(db, callback) {
    if (!this["@rid"]) {
        return callback(new Error("record cannot be deleted as it does not hold a DB Id"));
    }
    var Clazz = this.constructor;
    Clazz.delete(db, { "@rid": this["@rid"] }, function(err, total) {
        if (err) {
            callback(err);
        } else if (total != 1) {
            callback(new Error(total + " records deleted"));
        } else {
            callback(null, total);
        }
    });
};

DBClass.prototype.linkTo = function(db, target, clazz, callback) {
    var self = this;
    if (!callback && typeof clazz == "function") {
        callback = clazz;
        clazz = "E";
    }
    db.create("EDGE", clazz).from(self["@rid"]).to(target["@rid"]).one().then(function(e) {
        callback(null, e);
    }).catch(callback);
};

module.exports = DBClass;


var clazz = require("../src/clazz"),
    assert = require("assert");

describe("Test class", function() {
   
    function Parent(val1, val2) {
        this.val1 = val1;
        this.val2 = val2;
    }
   
    Parent.myStaticMethod = function() {
        return 3.14;
    };
   
    Parent.prototype.myMethod = function(x) {
        return this.val1 + 2.76 + x;
    };
    
    Parent.prototype.myMethod2 = function(x) {
        return this.myMethod(x);
    };
    
    it("can do basic inheritance", function() {
        function Child(val1, val2) {
           Parent.apply(this, arguments);
        }
        clazz.inherit(Child, Parent);

        var c = new Child(25, 36);
        assert(25 == c.val1);
        assert(36 == c.val2);
        assert("Child" == c.constructor.name);
        assert(typeof c.constructor.super_ !== "undefined");
        assert(25 + 2.76 + 3.1 == c.myMethod(3.1));
        assert(3.14 == Child.myStaticMethod());
    });

    it("can override instance and static methods", function() {
        function Child(val1, val2) {
           Parent.apply(this, arguments);
        }
        clazz.inherit(Child, Parent);
        
        Child.myStaticMethod = function() {
            return 101.24;
        };
        
        Child.prototype.myMethod = function() {
            return 24.1;
        };

        var c = new Child(25, 36);
        assert(25 == c.val1);
        assert(36 == c.val2);
        assert("Child" == c.constructor.name);
        assert(typeof c.constructor.super_ !== "undefined");
        assert(24.1 == c.myMethod());
        assert(101.24 == Child.myStaticMethod());
    });

    it("can call super methods", function() {
        function Child(val1, val2) {
           Parent.apply(this, arguments);
        }
        clazz.inherit(Child, Parent);
        
        Child.myStaticMethod = function() {
            return 25.0 + this.super_.myStaticMethod();
        };
        
        Child.prototype.myMethod = function(x) {
            return 24.1 + this.constructor.super_.prototype.myMethod.apply(this, arguments);
        };

        var c = new Child(25, 36);
        assert(25 == c.val1);
        assert(36 == c.val2);
        assert("Child" == c.constructor.name);
        assert(typeof c.constructor.super_ !== "undefined");
        assert(24.1 + 25 + 3.1 + 2.76 == c.myMethod(3.1));
        assert(28.14 == Child.myStaticMethod());
    });
    
    it("instance methods are virtual", function() {
        function Child(val1, val2) {
           Parent.apply(this, arguments);
        }
        clazz.inherit(Child, Parent);
        
        Child.prototype.myMethod = function(x) {
            return 24.1 + this.constructor.super_.prototype.myMethod.apply(this, arguments);
        };

        Child.prototype.myMethod2 = function(x) {
            // myMethod2 in the super call myMethod, so we expect it calls myMethod of this and not super
            return this.constructor.super_.prototype.myMethod2.apply(this, arguments);
        };

        var c = new Child(25, 36);
        assert(24.1 + 25 + 3.1 + 2.76 == c.myMethod2(3.1));

    });
});